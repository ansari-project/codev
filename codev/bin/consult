#!/usr/bin/env python3
"""Consult tool - wrapper for gemini-cli and codex CLI.

Provides a unified interface for multi-agent consultation via external AI CLIs.
Each invocation is stateless (fresh process).

Usage:
    consult gemini "Review this design"
    consult codex "What do you think of this API?"
    consult both "Review this"        # parallel consultation
    consult pro "Review this"         # alias for gemini
    consult gpt "Review this"         # alias for codex
    echo "Review this" | consult pro
"""

import concurrent.futures
import os
import shutil
import subprocess
import sys
import tempfile
from datetime import datetime
from pathlib import Path

try:
    import typer
except ImportError:
    print("Error: typer not installed. Run: pip install typer", file=sys.stderr)
    sys.exit(1)

# Model aliases
MODEL_MAP = {
    "pro": "gemini",
    "gpt": "codex",
}


def load_dotenv(codev_root: Path) -> None:
    """Load .env file from codev root if it exists."""
    env_file = codev_root / ".env"
    if not env_file.exists():
        return

    with open(env_file) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            if "=" in line:
                key, _, value = line.partition("=")
                key = key.strip()
                value = value.strip()
                # Remove surrounding quotes if present
                if (value.startswith('"') and value.endswith('"')) or \
                   (value.startswith("'") and value.endswith("'")):
                    value = value[1:-1]
                # Only set if not already in environment
                if key not in os.environ:
                    os.environ[key] = value


def find_codev_root() -> Path:
    """Find the codev root directory by walking up from cwd."""
    current = Path.cwd()
    for parent in [current] + list(current.parents):
        role_file = parent / "codev" / "roles" / "consultant.md"
        if role_file.exists():
            return parent
    return current  # Fallback to cwd


def get_role(role_file: Path) -> str:
    """Read the consultant role definition."""
    if not role_file.exists():
        typer.echo(f"Error: Role file not found: {role_file}", err=True)
        typer.echo("Are you in a codev-enabled project?", err=True)
        raise typer.Exit(1)
    return role_file.read_text()


def log_query(log_dir: Path, model: str, query: str) -> None:
    """Log consultation to .consult/history.log."""
    try:
        log_dir.mkdir(exist_ok=True)
        log_file = log_dir / "history.log"
        timestamp = datetime.now().isoformat()
        # Truncate long queries for log readability
        query_preview = query[:100].replace("\n", " ")
        if len(query) > 100:
            query_preview += "..."
        with open(log_file, "a") as f:
            f.write(f"{timestamp} model={model} query={query_preview}\n")
    except Exception:
        # Logging failure should not block consultation
        pass


def run_single_consultation(
    model: str, query: str, role: str, log_dir: Path
) -> tuple[str, int, str]:
    """Run a single consultation and return (model, exit_code, output)."""
    temp_system_file = None

    try:
        if model == "gemini":
            if not shutil.which("gemini"):
                return (model, 1, "Error: gemini-cli not found")
            temp_system_file = tempfile.NamedTemporaryFile(
                mode="w", suffix=".md", delete=False
            )
            temp_system_file.write(role)
            temp_system_file.close()
            cmd = ["gemini", "--yolo", query]
            env = {"GEMINI_SYSTEM_MD": temp_system_file.name}
        elif model == "codex":
            if not shutil.which("codex"):
                return (model, 1, "Error: codex not found")
            cmd = ["codex", "exec", "--full-auto", query]
            env = {"CODEX_SYSTEM_MESSAGE": role}
        else:
            return (model, 1, f"Unknown model: {model}")

        log_query(log_dir, model, query)

        full_env = {**os.environ, **env}
        result = subprocess.run(
            cmd, env=full_env, capture_output=True, text=True
        )
        output = result.stdout
        if result.stderr:
            # Filter out noisy stderr (like YOLO mode warnings)
            stderr_lines = [
                line for line in result.stderr.split("\n")
                if line and not line.startswith("YOLO mode")
                and "GOOGLE_API_KEY" not in line
                and "GEMINI_API_KEY" not in line
            ]
            if stderr_lines:
                output += "\n" + "\n".join(stderr_lines)
        return (model, result.returncode, output)
    finally:
        if temp_system_file:
            try:
                os.unlink(temp_system_file.name)
            except Exception:
                pass


def consult(
    model: str = typer.Argument(
        ..., help="Model: gemini, codex, both (or aliases: pro, gpt)"
    ),
    query: str = typer.Argument(
        None, help="Query (or pipe via stdin)"
    ),
    dry_run: bool = typer.Option(
        False, "--dry-run", "-n", help="Print command without executing"
    ),
) -> None:
    """Consult an external model for a second opinion.

    Examples:
        consult gemini "Review this architecture"
        consult codex "What's wrong with this code?"
        consult both "Review from both models"
        echo "Review this" | consult pro
    """
    # Lazy load paths
    codev_root = find_codev_root()
    role_file = codev_root / "codev" / "roles" / "consultant.md"
    log_dir = codev_root / ".consult"

    # Load .env file
    load_dotenv(codev_root)

    # Handle stdin
    if query is None:
        if not sys.stdin.isatty():
            query = sys.stdin.read().rstrip()
            if not query:
                typer.echo("Error: Empty input from stdin", err=True)
                raise typer.Exit(1)
        else:
            typer.echo("Error: No query provided", err=True)
            typer.echo("Usage: consult <model> <query>", err=True)
            raise typer.Exit(1)

    role = get_role(role_file)

    # Resolve model aliases
    resolved = MODEL_MAP.get(model.lower(), model.lower())

    # Handle parallel consultation
    if resolved in ("both", "all"):
        if dry_run:
            typer.echo("Would run parallel consultation with: gemini, codex")
            raise typer.Exit(0)

        typer.echo("=" * 60)
        typer.echo("PARALLEL CONSULTATION: gemini + codex")
        typer.echo("=" * 60 + "\n")

        with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
            futures = {
                executor.submit(run_single_consultation, m, query, role, log_dir): m
                for m in ["gemini", "codex"]
            }

            results = {}
            for future in concurrent.futures.as_completed(futures):
                model_name = futures[future]
                try:
                    results[model_name] = future.result()
                except Exception as e:
                    results[model_name] = (model_name, 1, f"Error: {e}")

        # Print results in order
        for m in ["gemini", "codex"]:
            model_name, exit_code, output = results[m]
            typer.echo(f"\n{'â”€' * 60}")
            typer.echo(f"ðŸ“‹ {model_name.upper()}")
            typer.echo(f"{'â”€' * 60}")
            typer.echo(output.strip())

        typer.echo(f"\n{'=' * 60}")
        raise typer.Exit(0)

    # Single model consultation
    # Track temp file for cleanup
    temp_system_file = None

    if resolved == "gemini":
        if not shutil.which("gemini"):
            typer.echo(
                "Error: gemini-cli not found.\n"
                "Install: https://github.com/google-gemini/gemini-cli",
                err=True,
            )
            raise typer.Exit(1)
        # gemini-cli uses GEMINI_SYSTEM_MD env var pointing to a file
        # Create a temp file with the role content
        temp_system_file = tempfile.NamedTemporaryFile(
            mode="w", suffix=".md", delete=False
        )
        temp_system_file.write(role)
        temp_system_file.close()
        cmd = ["gemini", "--yolo", query]
        env = {"GEMINI_SYSTEM_MD": temp_system_file.name}
    elif resolved == "codex":
        if not shutil.which("codex"):
            typer.echo(
                "Error: codex not found.\n"
                "Install: npm install -g @openai/codex",
                err=True,
            )
            raise typer.Exit(1)
        cmd = ["codex", "exec", "--full-auto", query]
        env = {"CODEX_SYSTEM_MESSAGE": role}
    else:
        typer.echo(
            f"Unknown model: {model}\n"
            f"Available: gemini, codex, both, pro, gpt",
            err=True,
        )
        raise typer.Exit(1)

    if dry_run:
        typer.echo(f"Command: {' '.join(cmd)}")
        if env:
            for key, value in env.items():
                # Show truncated env var for long values
                if key == "GEMINI_SYSTEM_MD":
                    typer.echo(f"Env: {key}=<temp file with consultant role>")
                else:
                    preview = value[:50] + "..." if len(value) > 50 else value
                    typer.echo(f"Env: {key}={preview}")
        # Clean up temp file if created
        if temp_system_file:
            os.unlink(temp_system_file.name)
        raise typer.Exit(0)

    log_query(log_dir, resolved, query)

    # Execute with passthrough stdio, handle Ctrl+C gracefully
    full_env = {**os.environ, **(env or {})}
    try:
        result = subprocess.run(cmd, env=full_env)
        raise typer.Exit(result.returncode)
    except KeyboardInterrupt:
        typer.echo("\nInterrupted", err=True)
        raise typer.Exit(130)
    finally:
        # Clean up temp file if created
        if temp_system_file:
            try:
                os.unlink(temp_system_file.name)
            except Exception:
                pass


if __name__ == "__main__":
    typer.run(consult)
