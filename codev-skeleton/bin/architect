#!/bin/bash
set -e

# Architect CLI - Manage builder agents for the Architect-Builder pattern
# Part of the Codev framework

# Paths
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
CODEV_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
PROJECT_ROOT="$(cd "$CODEV_DIR/.." && pwd)"
BUILDERS_DIR="$PROJECT_ROOT/.builders"
BUILDERS_MD="$CODEV_DIR/builders.md"
TEMPLATES_DIR="$CODEV_DIR/templates"
DASHBOARD_HTML="$TEMPLATES_DIR/dashboard.html"
PROMPT_TEMPLATE="$TEMPLATES_DIR/builder-prompt.md"
ANNOTATE_SERVER="$SCRIPT_DIR/annotate-server.js"
BASE_PORT=7681
ANNOTATE_PORT=8080

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print colored output
info() { echo -e "${BLUE}[info]${NC} $1"; }
success() { echo -e "${GREEN}[ok]${NC} $1"; }
warn() { echo -e "${YELLOW}[warn]${NC} $1"; }
error() { echo -e "${RED}[error]${NC} $1"; exit 1; }

# Check dependencies
check_deps() {
    if ! command -v git &> /dev/null; then
        error "git is required but not installed"
    fi
}

# Check if ttyd is available
check_ttyd() {
    if ! command -v ttyd &> /dev/null; then
        warn "ttyd is not installed. Install it with: brew install ttyd"
        return 1
    fi
    return 0
}

# Find next available port starting from BASE_PORT
find_available_port() {
    local port=$BASE_PORT
    while lsof -i :$port &> /dev/null; do
        ((port++))
    done
    echo $port
}

# Get builder worktree path
builder_path() {
    echo "$BUILDERS_DIR/$1"
}

# Get spec name from project ID
get_spec_name() {
    local id="$1"
    local spec_file=$(ls "$CODEV_DIR/specs/${id}-"*.md 2>/dev/null | head -1)
    if [[ -n "$spec_file" ]]; then
        basename "$spec_file" .md | sed "s/^${id}-//"
    else
        echo "unknown"
    fi
}

# ============================================================================
# SPAWN COMMAND
# ============================================================================
cmd_spawn() {
    local project_id=""
    local issue_num=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --project) project_id="$2"; shift 2 ;;
            --issue) issue_num="$2"; shift 2 ;;
            *) error "Unknown option: $1" ;;
        esac
    done

    if [[ -z "$project_id" && -z "$issue_num" ]]; then
        error "Usage: architect spawn --project XXXX or --issue NN"
    fi

    # If issue provided, we'd need to fetch spec from GitHub (placeholder for now)
    if [[ -n "$issue_num" ]]; then
        warn "Issue-based spawning not yet implemented"
        error "Please use --project XXXX instead"
    fi

    # Validate project exists
    local spec_name=$(get_spec_name "$project_id")
    local spec_file="$CODEV_DIR/specs/${project_id}-${spec_name}.md"
    local plan_file="$CODEV_DIR/plans/${project_id}-${spec_name}.md"

    if [[ ! -f "$spec_file" ]]; then
        error "Spec not found: $spec_file"
    fi

    if [[ ! -f "$plan_file" ]]; then
        warn "Plan not found: $plan_file (builder may need guidance)"
    fi

    # Check if builder already exists
    local builder_dir=$(builder_path "$project_id")
    if [[ -d "$builder_dir" ]]; then
        error "Builder $project_id already exists. Run 'architect cleanup $project_id' first."
    fi

    # Create builders directory if needed
    mkdir -p "$BUILDERS_DIR"

    # Create git worktree
    local branch_name="builder/${project_id}-${spec_name}"
    info "Creating worktree for $project_id..."

    cd "$PROJECT_ROOT"
    git worktree add -b "$branch_name" "$builder_dir" main 2>/dev/null || \
        git worktree add "$builder_dir" "$branch_name" 2>/dev/null || \
        error "Failed to create worktree"

    success "Worktree created: $builder_dir"

    # Generate builder prompt
    local prompt_file="$builder_dir/.builder-prompt.md"
    if [[ -f "$PROMPT_TEMPLATE" ]]; then
        sed -e "s/{{SPEC_ID}}/$project_id/g" \
            -e "s/{{SPEC_NAME}}/$spec_name/g" \
            "$PROMPT_TEMPLATE" > "$prompt_file"
        success "Builder prompt generated"
    fi

    # Check ttyd and start terminal
    if check_ttyd; then
        local port=$(find_available_port)
        info "Starting ttyd on port $port..."

        # Start ttyd in background
        nohup ttyd -p "$port" -W bash -c "cd '$builder_dir' && echo 'Builder $project_id ready. Run: claude' && exec bash" \
            > "$builder_dir/.ttyd.log" 2>&1 &

        local ttyd_pid=$!
        echo "$ttyd_pid" > "$builder_dir/.ttyd.pid"

        sleep 1
        if kill -0 "$ttyd_pid" 2>/dev/null; then
            success "ttyd started on port $port (PID: $ttyd_pid)"
            echo ""
            info "Open terminal: http://localhost:$port"
        else
            warn "ttyd may have failed to start. Check $builder_dir/.ttyd.log"
        fi
    else
        echo ""
        info "Builder worktree ready at: $builder_dir"
        info "Start Claude manually: cd $builder_dir && claude"
    fi

    # Update builders.md
    update_builders_md

    echo ""
    success "Builder $project_id spawned successfully!"
}

# ============================================================================
# STATUS COMMAND
# ============================================================================
cmd_status() {
    if [[ -f "$BUILDERS_MD" ]]; then
        cat "$BUILDERS_MD"
    else
        warn "No builders.md found"
    fi

    echo ""
    info "Active worktrees:"
    cd "$PROJECT_ROOT"
    git worktree list | grep -E "\.builders/" || echo "  (none)"
}

# ============================================================================
# DASHBOARD COMMAND
# ============================================================================
cmd_dashboard() {
    if [[ ! -f "$DASHBOARD_HTML" ]]; then
        error "Dashboard not found: $DASHBOARD_HTML"
    fi

    # Update dashboard with current builders
    update_dashboard

    # Open in browser
    if command -v open &> /dev/null; then
        open "$DASHBOARD_HTML"
    elif command -v xdg-open &> /dev/null; then
        xdg-open "$DASHBOARD_HTML"
    else
        info "Open in browser: file://$DASHBOARD_HTML"
    fi
}

# ============================================================================
# FILE REVIEW COMMANDS
# ============================================================================
cmd_files() {
    local builder_id="$1"
    [[ -z "$builder_id" ]] && error "Usage: architect files XXXX"

    local builder_dir=$(builder_path "$builder_id")
    [[ ! -d "$builder_dir" ]] && error "Builder $builder_id not found"

    cd "$builder_dir"
    git diff --name-status main...HEAD
}

cmd_diff() {
    local builder_id="$1"
    [[ -z "$builder_id" ]] && error "Usage: architect diff XXXX"

    local builder_dir=$(builder_path "$builder_id")
    [[ ! -d "$builder_dir" ]] && error "Builder $builder_id not found"

    cd "$builder_dir"
    git diff main...HEAD
}

cmd_cat() {
    local builder_id="$1"
    local file_path="$2"
    [[ -z "$builder_id" || -z "$file_path" ]] && error "Usage: architect cat XXXX path/to/file"

    local builder_dir=$(builder_path "$builder_id")
    [[ ! -d "$builder_dir" ]] && error "Builder $builder_id not found"

    local full_path="$builder_dir/$file_path"
    [[ ! -f "$full_path" ]] && error "File not found: $file_path"

    cat -n "$full_path"
}

cmd_review() {
    local builder_id="$1"
    [[ -z "$builder_id" ]] && error "Usage: architect review XXXX"

    local builder_dir=$(builder_path "$builder_id")
    [[ ! -d "$builder_dir" ]] && error "Builder $builder_id not found"

    local spec_name=$(get_spec_name "$builder_id")

    echo "Builder Review: $builder_id ($spec_name)"
    echo "============================================"
    echo ""

    cd "$builder_dir"

    echo "Branch: $(git branch --show-current)"
    echo "Commits ahead of main: $(git rev-list main..HEAD --count)"
    echo ""

    echo "Files Changed:"
    git diff --stat main...HEAD
    echo ""

    # Check for REVIEW comments
    local review_count=$(grep -r "REVIEW:" --include="*.ts" --include="*.js" --include="*.py" --include="*.md" . 2>/dev/null | wc -l | tr -d ' ')
    if [[ "$review_count" -gt 0 ]]; then
        echo "REVIEW Comments: $review_count"
        grep -rn "REVIEW:" --include="*.ts" --include="*.js" --include="*.py" --include="*.md" . 2>/dev/null | head -10
        [[ "$review_count" -gt 10 ]] && echo "  ... and $((review_count - 10)) more"
    fi
}

# ============================================================================
# ANNOTATION COMMANDS
# ============================================================================
cmd_annotate() {
    local builder_id="$1"
    local file_path="$2"
    [[ -z "$builder_id" || -z "$file_path" ]] && error "Usage: architect annotate XXXX path/to/file"

    local builder_dir=$(builder_path "$builder_id")
    [[ ! -d "$builder_dir" ]] && error "Builder $builder_id not found"

    local full_path="$builder_dir/$file_path"
    [[ ! -f "$full_path" ]] && error "File not found: $file_path"

    # Check for Node.js
    if ! command -v node &> /dev/null; then
        error "Node.js is required for the annotation viewer"
    fi

    # Find available port for annotation server
    local port=$ANNOTATE_PORT
    while lsof -i :$port &> /dev/null; do
        ((port++))
    done

    info "Starting annotation server on port $port..."

    # Start server and open browser
    cd "$PROJECT_ROOT"
    node "$ANNOTATE_SERVER" --builder "$builder_id" --file "$file_path" --port "$port" &
    local server_pid=$!

    sleep 1

    # Open in browser
    local url="http://localhost:$port"
    if command -v open &> /dev/null; then
        open "$url"
    elif command -v xdg-open &> /dev/null; then
        xdg-open "$url"
    else
        info "Open in browser: $url"
    fi

    echo ""
    info "Annotation server running (PID: $server_pid)"
    info "Press Ctrl+C to stop"

    # Wait for server
    wait $server_pid
}

cmd_annotations() {
    local builder_id="$1"
    [[ -z "$builder_id" ]] && error "Usage: architect annotations XXXX"

    local builder_dir=$(builder_path "$builder_id")
    [[ ! -d "$builder_dir" ]] && error "Builder $builder_id not found"

    echo "Files with REVIEW comments in builder $builder_id:"
    echo ""

    cd "$builder_dir"
    grep -rl "REVIEW:" --include="*.ts" --include="*.tsx" --include="*.js" --include="*.jsx" \
        --include="*.py" --include="*.md" --include="*.html" --include="*.css" \
        --include="*.yaml" --include="*.yml" --include="*.sh" . 2>/dev/null | \
        while read -r file; do
            count=$(grep -c "REVIEW:" "$file" 2>/dev/null || echo 0)
            echo "  $file ($count comments)"
        done

    echo ""
}

# ============================================================================
# CLEANUP COMMAND
# ============================================================================
cmd_cleanup() {
    local builder_id="$1"
    [[ -z "$builder_id" ]] && error "Usage: architect cleanup XXXX"

    local builder_dir=$(builder_path "$builder_id")
    [[ ! -d "$builder_dir" ]] && error "Builder $builder_id not found"

    # Stop ttyd if running
    local pid_file="$builder_dir/.ttyd.pid"
    if [[ -f "$pid_file" ]]; then
        local pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            info "Stopping ttyd (PID: $pid)..."
            kill "$pid" 2>/dev/null || true
        fi
    fi

    # Remove worktree
    info "Removing worktree..."
    cd "$PROJECT_ROOT"
    git worktree remove --force "$builder_dir" 2>/dev/null || rm -rf "$builder_dir"

    # Optionally delete branch
    local spec_name=$(get_spec_name "$builder_id")
    local branch_name="builder/${builder_id}-${spec_name}"

    read -p "Delete branch $branch_name? [y/N] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        git branch -D "$branch_name" 2>/dev/null && success "Branch deleted" || warn "Could not delete branch"
    fi

    # Update builders.md
    update_builders_md

    success "Builder $builder_id cleaned up"
}

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================
update_builders_md() {
    # This is a simple implementation - could be enhanced
    # For now, just regenerate the active builders section

    local header="# Active Builders

Track active builder agents here. Update manually or via \`architect status\`.

## Status Values

- **spawning**: Worktree being created, ttyd starting
- **implementing**: Builder is working
- **blocked**: Builder waiting for architect input
- **pr-ready**: Builder has created a PR
- **reviewing**: Architect is reviewing the PR
- **complete**: PR merged, ready for cleanup

---

## Builders

"

    echo "$header" > "$BUILDERS_MD"

    # List active builders
    local found=false
    if [[ -d "$BUILDERS_DIR" ]]; then
        for builder_dir in "$BUILDERS_DIR"/*/; do
            [[ -d "$builder_dir" ]] || continue
            found=true

            local builder_id=$(basename "$builder_dir")
            local spec_name=$(get_spec_name "$builder_id")
            local branch_name="builder/${builder_id}-${spec_name}"
            local port="(unknown)"
            local started="(unknown)"

            # Try to get port from ttyd pid
            local pid_file="$builder_dir/.ttyd.pid"
            if [[ -f "$pid_file" ]]; then
                local pid=$(cat "$pid_file")
                if kill -0 "$pid" 2>/dev/null; then
                    # Try to find port from process
                    port=$(lsof -Pan -p "$pid" -i 2>/dev/null | grep LISTEN | awk '{print $9}' | cut -d: -f2 | head -1)
                    [[ -z "$port" ]] && port="(running)"
                fi
            fi

            # Get start time from worktree creation
            if [[ -d "$builder_dir" ]]; then
                started=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$builder_dir" 2>/dev/null || \
                         stat -c "%y" "$builder_dir" 2>/dev/null | cut -d. -f1)
            fi

            cat >> "$BUILDERS_MD" << EOF
### Builder $builder_id: $spec_name
- **Branch**: $branch_name
- **Port**: $port
- **Status**: implementing
- **Started**: $started

EOF
        done
    fi

    if [[ "$found" == false ]]; then
        echo "(No active builders)" >> "$BUILDERS_MD"
    fi
}

update_dashboard() {
    # Generate JavaScript array of active builders
    local builders_js="["

    if [[ -d "$BUILDERS_DIR" ]]; then
        local first=true
        for builder_dir in "$BUILDERS_DIR"/*/; do
            [[ -d "$builder_dir" ]] || continue

            local builder_id=$(basename "$builder_dir")
            local spec_name=$(get_spec_name "$builder_id")
            local port=""

            # Try to get port
            local pid_file="$builder_dir/.ttyd.pid"
            if [[ -f "$pid_file" ]]; then
                local pid=$(cat "$pid_file")
                if kill -0 "$pid" 2>/dev/null; then
                    port=$(lsof -Pan -p "$pid" -i 2>/dev/null | grep LISTEN | awk '{print $9}' | cut -d: -f2 | head -1)
                fi
            fi

            [[ -z "$port" ]] && continue

            [[ "$first" == false ]] && builders_js+=","
            first=false
            builders_js+="
      { id: '$builder_id', name: '$spec_name', port: $port, status: 'implementing', phase: '1/?' }"
        done
    fi

    builders_js+="
    ]"

    # Update dashboard.html
    if [[ -f "$DASHBOARD_HTML" ]]; then
        # Create temp file with updated builders
        sed "s/const builders = \[.*\];/const builders = $builders_js;/" "$DASHBOARD_HTML" > "$DASHBOARD_HTML.tmp"
        mv "$DASHBOARD_HTML.tmp" "$DASHBOARD_HTML"
    fi
}

# ============================================================================
# MAIN
# ============================================================================
check_deps

case "${1:-help}" in
    spawn)      shift; cmd_spawn "$@" ;;
    status)     cmd_status ;;
    dashboard)  cmd_dashboard ;;
    files)      shift; cmd_files "$@" ;;
    diff)       shift; cmd_diff "$@" ;;
    cat)        shift; cmd_cat "$@" ;;
    review)     shift; cmd_review "$@" ;;
    annotate)   shift; cmd_annotate "$@" ;;
    annotations) shift; cmd_annotations "$@" ;;
    cleanup)    shift; cmd_cleanup "$@" ;;
    help|--help|-h)
        echo "Architect CLI - Manage builder agents"
        echo ""
        echo "Usage: architect <command> [options]"
        echo ""
        echo "Commands:"
        echo "  spawn --project XXXX    Create a new builder for a project"
        echo "  spawn --issue NN        Create a new builder from GitHub issue"
        echo "  status                  Show status of all builders"
        echo "  dashboard               Open web dashboard"
        echo "  files XXXX              List files changed by builder"
        echo "  diff XXXX               Show diff of builder's changes"
        echo "  cat XXXX FILE           View a file in builder's worktree"
        echo "  review XXXX             Show review summary for builder"
        echo "  annotate XXXX FILE      Open annotation viewer for file"
        echo "  annotations XXXX        List files with REVIEW comments"
        echo "  cleanup XXXX            Remove builder and worktree"
        echo ""
        echo "Examples:"
        echo "  architect spawn --project 0003"
        echo "  architect status"
        echo "  architect files 0003"
        echo "  architect annotate 0003 src/auth/login.ts"
        echo "  architect cleanup 0003"
        ;;
    *)
        error "Unknown command: $1. Run 'architect help' for usage."
        ;;
esac
